import requests
from datetime import  timedelta

from datetime import datetime
from django.core.cache import cache

def getIndicator(ticker , timespan , type):
    api_key = 'juwfn1N0Ka0y8ZPJS4RLfMCLsm2d4IR2'
    data = requests.get(f'https://financialmodelingprep.com/api/v3/technical_indicator/{timespan}/{ticker}?type={type}&period=14&apikey={api_key}')
    return data.json()


######
tickers = [
"EDD",
"EDF",
"EDIT",
"EDR",
"EDSA",
"EDUC",
"EE",
"EEA",
"EEFT",
"EEIQ",
"EEX",
"EFC",
"EFOI",
"EFR",
"EFSC",
"EFSCP",
"EFT",
"EFX",
"EGAN",
"EGBN",
"EGF",
"EGHT",
"EGIO",
"EGP",
"EGRX",
"EGY",
"EHAB",
"EHC",
"EHI",
"EHTH",
"EIG",
"EIM",
"EIX",
"EKSO",
"EL",
"ELA",
"ELAB",
"ELAN",
"ELC",
"ELDN",
"ELEV",
"ELF",
"ELMD",
"ELME",
"ELS",
"ELSE",
"ELTX",
"ELUT",
"ELV",
"ELVN",
"ELYM",
"EMBC",
"EMCG",
"EMCGU",
"EMD",
"EME",
"EMF",
"EMKR",
"EML",
"EMN",
"EMO",
"EMP",
"EMR",
"ENFN",
"ENG",
"ENJ",
"ENLC",
"ENO",
"ENOV",
"ENPH",
"ENR",
"ENS",
"ENSC",
"ENSG",
"ENSV",
"ENTA",
"ENTG",
"ENTO",
"ENV",
"ENVA",
"ENVB",
"ENVX",
"ENX",
"ENZ",
"EOD",
"EOG",
"EOI",
"EOLS",
"EOSE",
"EOSE",
"EOT",
"EP",
"EPAC",
"EPAM",
"EPC",
"EPD",
"EPM",
"EPR",
"EPRT",
"EPSN",
"EQ",
"EQBK",
"EQC",
"EQH",
"EQIX",
"EQR",
"EQS",
"EQT",
"ERAS",
"ERC",
"ERIE",
"ERII",
"ERNA",
"ES",
"ESAB",
"ESCA",
"ESE",
"ESHA",
"ESHAR",
"ESI",
"ESLA",
"ESLAW",
"ESOA",
"ESP",
"ESPR",
"ESQ",
"ESRT",
"ESS",
"ESSA",
"ESTC",
"ET",
"ETB",
"ETD",
"ETG",
"ETHA",
"ETJ",
"ETNB",
"ETO",
"ETON",
"ETR",
"ETSY",
"ETV",
"ETW",
"ETWO",
"ETY",
"EU",
"EURKU",
"EVA",
"EVBN",
"EVC",
"EVCM",
"EVER",
"EVF",
"EVG",
"EVGO",
"EVGOW",
"EVH",
"EVI",
"EVLV",
"EVLVW",
"EVM",
"EVN",
"EVOK",
"EVR",
"EVRG",
"EVRI",
"EVT",
"EVTV",
"EVV",
"EW",
"EWBC",
"EWCZ",
"EWTX",
"EXAS",
"EXC",
"EXEL",
"EXFY",
"EXG",
"EXLS",
"EXP",
"EXPD",
"EXPE",
"EXPI",
"EXPO",
"EXR",
"EXTR",
"EYE",
"EYEN",
"EYPT",
"EZFL",
"EZPW",
"F",
"FA",
"FAAS",
"FAASW",
"FAF",
"FAM",
"FANG",
"FARM",
"FARO",
"FAST",
"FAT",
"FATBB",
"FATBP",
"FATBW",
"FATE",
"FAX",
"FBIN",
"FBIO",
"FBIOP",
"FBIZ",
"FBK",
"FBLG",
"FBMS",
"FBNC",
"FBRT",
"FBRX",
"FBYD",
"FBYDW",
"FC",
"FCAP",
"FCBC",
"FCCO",
"FCEL",
"FCF",
"FCFS",
"FCN",
"FCNCA",
"FCNCO",
"FCNCP",
"FCO",
"FCPT",
"FCRX",
"FCT",
"FCUV",
"FCX",
"FDBC",
"FDMT",
"FDS",
"FDSB",
"FDUS",
"FDX",
"FE",
"FEAM",
"FEIM",
"FELE",
"FEMY",
"FENC",
"FET",
"FF",
"FFA",
"FFBC",
"FFC",
"FFIC",
"FFIE",
"FFIEW",
"FFIN",
"FFIV",
"FFNW",
"FFWM",
"FG",
"FGB",
"FGBI",
"FGBIP",
"FGEN",
"FGF",
"FGFPP",
"FGI",
"FGIWW",
"FGN",
"FHB",
"FHI",
"FHN",
"FHTX",
"FI",
"FIAC",
"FIACU",
"FIBK",
"FICO",
"FIGS",
"FINV",
"FINW",
"FIP",
"FIS",
"FISI",
"FITB",
"FITBI",
"FITBO",
"FITBP",
"FIVE",
"FIVN",
"FIX",
"FIZZ",
"FKWL",
"FL",
"FLC",
"FLD",
"FLDDU",
"FLDDW",
"FLGT",
"FLIC",
"FLL",
"FLNC",
"FLNT",
"FLO",
"FLR",
"FLS",
"FLUX",
"FLWS",
"FLXS",
"FLYE",
"FLYW",
"FMAO",
"FMBH",
"FMC",
"FMN",
"FMNB",
"FMY",
"FNA",
"FNB",
"FND",
"FNF",
"FNGR",
"FNKO",
"FNLC",
"FNWB",
"FNWD",
"FOA",
"FOF",
"FOLD",
"FONR",
"FOR",
"FORA",
"FORD",
"FORL",
"FORM",
"FORR",
"FOSL",
"FOSLL",
"FOUR",
"FOX",
"FOXA",
"FOXF",
"FPAY",
"FPF",
"FPH",
"FPI",
"FR",
"FRA",
"FRAF",
"FRBA",
"FRD",
"FRGE",
"FRGT",
"FRLA",
"FRLAW",
"FRME",
"FRMEP",
"FROG",
"FRPH",
"FRPT",
"FRSH",
"FRST",
"FRT",
"FRZA",
"FSBC",
"FSBW",
"FSCO",
"FSEA",
"FSFG",
"FSHP",
"FSHPR",
"FSHPU",
"FSK",
"FSLR",
"FSLY",
"FSP",
"FSS",
"FSTR",
"FSUN",
"FT",
"FTAI",
"FTAIM",
"FTAIN",
"FTAIO",
"FTAIP",
"FTCI",
"FTDR",
"FTEK",
"FTF",
"FTHM",
"FTHY",
"FTII",
"FTIIW",
"FTK",
"FTLF",
"FTNT",
"FTRE",
"FTS",
"FTV",
"FUBO",
"FUL",
"FULC",
"FULT",
"FULTP",
"FUN",
"FUNC",
"FUND",
"FUSB",
"FVCB",
"FWONA",
"FWONK",
"FWRD",
"FWRG",
"FXNC",
"FYBR",
"GAB",
"GABC",
"GAIA",
"GAIN",
"GAINL",
"GAINN",
"GAINZ",
"GALT",
"GAM",
"GAME",
"GANX",
"GAP",
"GATE",
"GATO",
"GATX",
"GBAB",
"GBBK",
"GBCI",
"GBDC",
"GBIO",
"GBNY",
"GBR",
"GBTG",
"GBX",
"GCBC",
"GCI",
"GCMG",
"GCMGW",
"GCO",
"GCV",
"GD",
"GDDY",
"GDEN",
"GDL",
"GDO",
"GDOT",
"GDRX",
"GDSTU",
"GDV",
"GDYN",
"GE",
"GECC",
"GECCI",
"GECCM",
"GECCZ",
"GEF",
"GEG",
"GEGGL",
"GEHC",
"GEL",
"GEN",
"GENC",
"GENK",
"GEO",
"GEOS",
"GERN",
"GES",
"GETY",
"GEV",
"GEVO",
"GF",
"GFF",
"GFS",
"GGG",
"GGN",
"GGT",
"GH",
"GHC",
"GHI",
"GHIX",
"GHIXU",
"GHIXW",
"GHLD",
"GHM",
"GHSI",
"GHY",
"GIC",
"GIFI",
"GIFT",
"GIG",
"GIGGU",
"GIGGW",
"GIII",
"GILD",
"GIPR",
"GIPRW",
"GIS",
"GJH",
"GJO",
"GJP",
"GJR",
"GJS",
"GJT",
"GKOS",
"GL",
"GLAD",
"GLADZ",
"GLBZ",
"GLDD",
"GLO",
"GLOB",
"GLP",
"GLPI",
"GLQ",
"GLSI",
"GLT",
"GLU",
"GLUE",
"GLV",
"GLW",
"GLYC",
"GM",
"GME",
"GMED",
"GMGI",
"GMRE",
"GMS",
"GNE",
"GNK",
"GNL",
"GNLN",
"GNLX",
"GNPX",
"GNRC",
"GNSS",
"GNT",
"GNTX",
"GNTY",
"GNW",
"GO",
"GOCO",
"GODN",
"GODNR",
"GOEV",
"GOEVW",
"GOF",
"GOGO",
"GOLF",
"GOOD",
"GOODN",
"GOODO",
"GOOG",
"GOOGL",
"GORO",
"GORV",
"GOSS",
"GOVX",
"GOVXW",
"GPAT",
"GPC",
"GPCR",
"GPI",
"GPJA",
"GPK",
"GPMT",
"GPN",
"GPOR"]
######
timespan = '4hour'
## check the limitation number of days accourding to timespan ##
if timespan == '1day' or timespan == '4hour':
    limit_number_days = 30
elif timespan == '1hour':
    limit_number_days = 7
## get the limitation date ##
limit_date  = datetime.today() - timedelta(days=limit_number_days)

for ticker in tickers:
    print(f'Major {timespan} {ticker}')
    counter = 0 ## number of candies that has the same range value 
    largest_number= 0
    smallest_number= 1000000000000000000
    results = getIndicator(ticker=ticker , timespan=timespan , type='rsi')
    if results!= []:
        print("result not []")
        # try:
        for result in results[1:]:
            ## convert string date to date type ##
            date_of_result = datetime.strptime(result['date'] , "%Y-%m-%d %H:%M:%S")
            if date_of_result >= limit_date:
                print(f"date of result = {date_of_result}")
                print(f"limit date = {limit_date}")
                
            ## check condition of strategy (range of price and date) ## 
                if (
                    ((abs(results[0]['open']-result['open']) <= 0.8) or 
                    (abs(results[0]['open']-result['close']) <= 0.8) or 
                    (abs(results[0]['close']-result['open']) <= 0.8) or 
                    (abs(results[0]['close']-result['open']) <= 0.8))
                ):
                    largest_number = max(results[0]['open'], results[0]['close'], result['open'],result['close'], largest_number)
                    smallest_number = min(results[0]['open'], results[0]['close'], result['open'],result['close'], smallest_number)
            else:
                if counter >= 5:
                    range_of_price = (largest_number+smallest_number)/2
                    print(f"alert with counter = {counter}")
                break
            
        # except Exception as e:
        #     print({"Error" : e })
        #      continue
